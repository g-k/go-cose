
package main


// script to generate code from IANA csvs

import (
	"encoding/csv"
	"fmt"
	"os"
	"io"
	"io/ioutil"
	"log"
	"path/filepath"
)


// GoFileTemplate format strings for a generated code file
type GoFileTemplate struct {
	filename string
	header string
	item string
	footer string
	formatFunc func (formatStr string, record []string) (line string)
}

var fileTemplates = map[string]GoFileTemplate{
	"algorithms.csv": GoFileTemplate{
		filename: "algorithms.go",
		header: `
// COSE Algorithms
//
// This file is autogenerated modify util/from_csv.go to change it.

package cose

type COSEAlgorithm struct {
	Name string
	Value int
}

var COSEAlgorithms = []COSEAlgorithm{
`,
		item: `	COSEAlgorithm{
		Name: "%s",  // %s from %s
		Value: %s,
	},
`,
		footer: `}
`,
		formatFunc: func (formatStr string, record []string) (line string) {
			Name, Value, Description, Reference, Recommended := record[0], record[1], record[2], record[3], record[4]
			if Name == "Unassigned" || Name == "Reserved" || Recommended == "No" {
				return ""
			}
			return fmt.Sprintf(formatStr, Name, Description, Reference, Value)
		},
	},
	"elliptic-curves.csv": GoFileTemplate{
		filename: "curves.go",
		header: `
// COSE Elliptic Curves
//
// This file is autogenerated modify util/from_csv.go to change it.

package cose

type COSEEllipticCurve struct {
	Name string
	Value int
        KeyType string
}

var COSEEllipticCurves = []COSEEllipticCurve{
`,
		item: `	COSEEllipticCurve{
		Name: "%s",  // %s from %s
		Value: %s,
                KeyType: "%s",
	},
`,
		footer: `}
`,
		formatFunc: func (formatStr string, record []string) (line string) {
			Name, Value, KeyType, Description, Reference, Recommended := record[0], record[1], record[2], record[3], record[4], record[5]
			if Name == "Unassigned" || Name == "Reserved" || Recommended == "No" {
				return ""
			}
			return fmt.Sprintf(formatStr, Name, Description, Reference, Value, KeyType)
		},
	},
}


func getFout(goFilePath string) (fout *os.File) {
	fout, err := os.Create(goFilePath)
	if err != nil {
		log.Fatal(err)
	}
	return fout
}


func main() {
	outputDir := "generated"
	dataDir := "util/data"
	files, err := ioutil.ReadDir(dataDir)
	if err != nil {
		log.Fatal(err)
	}

	for _, file := range files {
		if file.IsDir() {
			continue
		}
		template, ok := fileTemplates[file.Name()]
		if !ok {
			continue
		}

		goFilePath := filepath.Join(outputDir, template.filename)
		csvPath := filepath.Join(dataDir, file.Name())
		fmt.Println(fmt.Sprintf("Loading: %s and writing to %s", csvPath, goFilePath))

		fout := getFout(goFilePath)
		defer fout.Close()

		fout.WriteString(template.header)

		var reader, err = os.Open(csvPath)
		if err != nil {
			log.Fatal(err)
		}

		r := csv.NewReader(reader)
		var lineNo = 0
		for {
			record, err := r.Read()
			lineNo++
			if lineNo == 1 {  // skip first line which describes the columns
				continue
			}

			if err == io.EOF {
				break
			}
			if err != nil {
				log.Fatal(err)
			}
			fout.WriteString(template.formatFunc(template.item, record))
		}
		fout.WriteString(template.footer)
	}
}
